<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Longest Substring Visualizer</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center p-4">
  <h1 class="text-3xl font-bold mb-6">Longest Substring Without Repeating Characters</h1>

  <!-- Input Section -->
  <div class="w-full max-w-md bg-white p-6 rounded-lg shadow-md">
    <label for="inputString" class="block text-lg font-medium mb-2">Input String</label>
    <input id="inputString" type="text" 
           class="w-full border border-gray-300 rounded-md p-2 mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500">

    <button id="visualizeButton" 
            class="w-full bg-blue-500 text-white py-2 rounded-md hover:bg-blue-600 transition">
      Visualize Algorithm
    </button>
  </div>

  <!-- Visualization Section -->
  <div id="visualization" class="w-full max-w-4xl mt-8 bg-white p-6 rounded-lg shadow-md hidden">
    <h2 class="text-xl font-semibold mb-4">Algorithm Visualization</h2>
    <div id="inputBoxes" class="flex space-x-2 mb-4"></div>
    <div id="window" class="flex space-x-2 relative"></div>
    <div id="result" class="mt-4 text-gray-800 font-semibold"></div>

    <!-- Control Buttons -->
    <div class="mt-6 flex space-x-4">
      <button id="startButton" 
              class="bg-green-500 text-white px-4 py-2 rounded-md hover:bg-green-600 transition">
        Start
      </button>
      <button id="prevButton" 
              class="bg-gray-500 text-white px-4 py-2 rounded-md hover:bg-gray-600 transition">
        Prev
      </button>
      <button id="nextButton" 
              class="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600 transition">
        Next
      </button>
      <button id="resetButton" 
              class="bg-red-500 text-white px-4 py-2 rounded-md hover:bg-red-600 transition">
        Reset
      </button>
    </div>
  </div>

  <script>const visualizeButton = document.getElementById("visualizeButton");
    const startButton = document.getElementById("startButton");
    const prevButton = document.getElementById("prevButton");
    const nextButton = document.getElementById("nextButton");
    const resetButton = document.getElementById("resetButton");
    
    const inputBoxes = document.getElementById("inputBoxes");
    const windowDiv = document.getElementById("window");
    const resultDiv = document.getElementById("result");
    const visualization = document.getElementById("visualization");
    
    let steps = []; // Store all the steps of the algorithm
    let currentStep = 0;
    let animationInterval = null;
    
    // Generate steps for the sliding window algorithm
    function generateSteps(input) {
      const seen = new Map();
      let start = 0,
        maxLength = 0,
        longestSubstring = ""; // Track the longest substring
      steps = []; // Reset steps
    
      for (let end = 0; end < input.length; end++) {
        const currentChar = input[end];
        if (seen.has(currentChar) && seen.get(currentChar) >= start) {
          start = seen.get(currentChar) + 1;
        }
        seen.set(currentChar, end);
    
        const currentLength = end - start + 1;
        if (currentLength > maxLength) {
          maxLength = currentLength;
          longestSubstring = input.slice(start, end + 1); // Update longest substring
        }
    
        // Record the current step
        steps.push({
          start,
          end,
          currentWindow: input.slice(start, end + 1),
          currentLength,
          maxLength,
          longestSubstring,
        });
      }
    
      // Final result step
      steps.push({
        finalResult: `The length of the longest substring is ${maxLength}, and the substring is "${longestSubstring}".`,
        longestSubstring,
      });
    }
    
    // Render a specific step
    function renderStep(stepIndex) {
      const step = steps[stepIndex];
      if (!step) return;
    
      // Highlight the current window
      windowDiv.innerHTML = "";
      const inputString = document.getElementById("inputString").value.trim();
    
      inputString.split("").forEach((char, index) => {
        const box = document.createElement("div");
        box.textContent = char;
        box.className = `text-xl w-10 h-10 flex items-center justify-center border rounded shadow-md ${
          index >= step.start && index <= step.end ? "bg-blue-400 text-white" : "bg-gray-200"
        }`;
        windowDiv.appendChild(box);
      });
    
      // Update result section
      resultDiv.innerHTML = step.finalResult
        ? `<p class="text-green-600"><strong>${step.finalResult}</strong></p>`
        : `
          <p>Current Window: <span class="text-blue-500">"${step.currentWindow}"</span></p>
          <p>Current Length: ${step.currentLength}, Max Length: ${step.maxLength}</p>
          <p>Longest Substring So Far: <span class="text-green-500">"${step.longestSubstring}"</span></p>
        `;
    }
    
    // Button actions
    visualizeButton.addEventListener("click", () => {
      const inputString = document.getElementById("inputString").value.trim();
      if (!inputString) {
        alert("Please enter a valid string!");
        return;
      }
    
      generateSteps(inputString); // Generate steps for the input
      visualization.classList.remove("hidden"); // Show visualization section
      renderStep(0); // Render the first step
      currentStep = 0;
    });
    
    startButton.addEventListener("click", () => {
      if (animationInterval) return; // Avoid multiple intervals
      animationInterval = setInterval(() => {
        if (currentStep >= steps.length - 1) {
          clearInterval(animationInterval);
          animationInterval = null;
          return;
        }
        renderStep(++currentStep);
      }, 1000); // Auto-play every 1 second
    });
    
    prevButton.addEventListener("click", () => {
      if (currentStep > 0) {
        renderStep(--currentStep);
      }
    });
    
    nextButton.addEventListener("click", () => {
      if (currentStep < steps.length - 1) {
        renderStep(++currentStep);
      }
    });
    
    resetButton.addEventListener("click", () => {
  // Clear any ongoing interval
  clearInterval(animationInterval);
  animationInterval = null;

  // Reset step tracker
  currentStep = 0;

  // Clear input fields
  document.getElementById("inputString").value = ""; // Clear the input string

  // Hide visualization section
  visualization.classList.add("hidden");

  // Clear all visualization content (input boxes, window, result)
  inputBoxes.innerHTML = "";
  windowDiv.innerHTML = "";
  resultDiv.innerHTML = "";
});

    </script>
</body>
</html>

